using Tyche;
using Tyche.DDD.Application;
using Ninject;
using Tyche.DDD.GUI;
using System.Reflection;
using System.Collections.Generic;
using Castle.DynamicProxy.Generators.Emitters;
using System.Configuration;
using System.Data;
using Newtonsoft.Json.Linq;
using Tyche.DDD.Domain.Models.Randomness.Distributions;


namespace Tyche.Tests
{
   [TestFixture]
    public class Tests
    {
        [Test]
        public void EngineIsSingletonInstance()
        {
            var kernel = new StandardKernel(new EngineModule());
            Assert.That(kernel.Get<Engine>(), Is.EqualTo(kernel.Get<Engine>()));
        }

        [Test]
        public void GuiFormsAreNotSingletonInstances()
        {
            var kernel = new StandardKernel(new EngineModule());
            Assert.That(kernel.Get<SettingsForm>(), !Is.EqualTo(kernel.Get<SettingsForm>()));
            Assert.That(kernel.Get<MainForm>(), !Is.EqualTo(kernel.Get<MainForm>()));
        }

        [Test]
        public void DoubleNanWhenWrongInputRangeForExponentalAndNormalDistributions()
        {
            var kernel = new StandardKernel(new EngineModule());
            var engine = kernel.Get<Engine>();
            var distributionType = Engine.DistributionType.NormalDistribution;
            var randomType = Engine.RandomType.PCGRandom;
            Assert.AreEqual(engine.GenerateDistributionValue(2, 3, distributionType, randomType), double.NaN);
            distributionType = Engine.DistributionType.ExponentialDistribution;
            Assert.AreEqual(engine.GenerateDistributionValue(2, 3, distributionType, randomType), double.NaN);
        }

        [Test]
        public void EngineUsingNewRandomsWhenSettingsApplied()
        {
            var kernel = new StandardKernel(new EngineModule());
            var engine = kernel.Get<Engine>();
            Type engineType = typeof(Engine);

            // Get randoms with old seed

            FieldInfo fieldInfo = engineType.GetField("randoms", BindingFlags.NonPublic | BindingFlags.Instance);
            var randoms_old = (Dictionary <RandomInformation, Random>)fieldInfo.GetValue(engine);
          
            // Change seed

            ChangeParameters();
            SaveSettings();
            engine.ReloadRandoms();

            // Get randoms with new seed

            var randoms_new = (Dictionary<RandomInformation, Random>)fieldInfo.GetValue(engine);

            // Check that values are not equals

            for (int i = 0; i< randoms_new.Values.Count; i++)
            {
                var val1 = randoms_new.Values.ToList()[i].Next();
                var val2 = randoms_old.Values.ToList()[i].Next();
                Assert.That(val1, !Is.EqualTo(val2));
            }
        }

        [Test]
        public void EngineUsingNewDistributionsWhenSettingsApplied()
        {
            // This test does not check Uniform Distribution because this type of distribution has no parameters
            var kernel = new StandardKernel(new EngineModule());
            var engine = kernel.Get<Engine>();
            Type engineType = typeof(Engine);
            var values_old = new List<double>();
            var values_new = new List<double>();

            // Get distributions with old parameters

            FieldInfo fieldInfo = engineType.GetField("distributions", BindingFlags.NonPublic | BindingFlags.Instance);
            var distributions_old = (Dictionary<DistributionInformation, AbstractContinuousDistribution>)fieldInfo.GetValue(engine);

            // Get values generated by old distributions

            for (int i = 0; i < distributions_old.Keys.Count; i++)
            {
                var type = distributions_old.Keys.ToList()[i].Type;
                if (type == Engine.DistributionType.UniformDistribution)
                    continue;
                values_old.Add(engine.GenerateDistributionValue(0, 1, type, Engine.RandomType.LCGRandom));
            }

            // Reload randoms with the same seed and change distributions parameters

            engine.ReloadRandoms();
            ChangeParameters();
            SaveSettings();
            engine.ReloadDistributions();

            // Get distributions with new parameters

            var distributions_new = (Dictionary<DistributionInformation, AbstractContinuousDistribution>)fieldInfo.GetValue(engine);
            for (int i = 0; i < distributions_new.Keys.Count; i++)
            {
                var type = distributions_new.Keys.ToList()[i].Type;
                if (type == Engine.DistributionType.UniformDistribution)
                    continue;
                values_new.Add(engine.GenerateDistributionValue(0, 1, type, Engine.RandomType.LCGRandom));
            }

            // Check that values are not equals

            for (int i = 0; i < values_old.Count; i++)
                Assert.That(values_old[i], !Is.EqualTo(values_new[i]));
        }

        public void ChangeParameters()
        {
            foreach (SettingsProperty prop in Properties.Settings.Default.Properties)
            {
                var value = Convert.ChangeType(Properties.Settings.Default[prop.Name], prop.PropertyType);
                dynamic obj = value;
                obj += 5;
                Properties.Settings.Default[prop.Name] = obj;
            }
        }

        public void SaveSettings()
        {
            Properties.Settings.Default.Save();
            Properties.Settings.Default.Reload();
            Properties.Settings.Default.Upgrade();
        }

    }
}